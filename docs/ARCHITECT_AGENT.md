# Architect Agent — Detailed Design Specification

## 1. Purpose (Authoritative Statement)

The **Architect Agent** (also referred to as the Planner) is the *sole authority* responsible for translating a validated **intent specification** into a **stable, executable architecture plan**.

Its responsibility is strictly limited to:
- Defining architectural structure
- Naming and stabilizing execution units
- Declaring dependencies and generation order
- Mapping execution layers to **predefined generator agents**

> The Architect decides **what exists**.  
> The Orchestrator decides **what runs and when**.  
> Agents decide **how code is written**.

The Architect **never**:
- Generates code
- Discovers or invents agents
- Performs diffing or impact analysis
- Executes workflows
- Mutates files directly

---

## 2. Position in the Overall Architecture

- Implemented as **one LangGraph node** in the global graph
- Always executed **after the Intent Interpreter**
- Executed:
  - Once during initial app creation
  - Again after intent evolution (user feedback)

The Architect outputs a **single authoritative artifact**:
```
architecture.json
```

This artifact is the **contract between planning and execution**.

---

## 3. Core Design Principles

The Architect Agent adheres to the following principles:

1. **Statelessness**  
   - The Architect does not track history internally

2. **Structural determinism**  
   - Given the same inputs, it must produce structurally equivalent output

3. **Stable identifiers**  
   - Architectural identifiers are immutable once created

4. **Additive evolution only**  
   - Existing components are preserved across iterations

5. **Explicit dependency declaration**  
   - All execution order is defined declaratively

6. **Closed-world agent selection**  
   - The Architect may only use agents provided by the system

---

## 4. Agent Registry (Critical System Configuration)

### 4.1 Purpose of the Agent Registry

The **Agent Registry** defines the complete, closed set of generator agents available to the system.

It is:
- Authored by the system designer (not an LLM)
- Static and version-controlled
- Passed to the Architect as **read-only context**

The Architect **does not discover agents dynamically** and **must not invent new agents**.

> The Architect plans using a known toolbox.

---

### 4.2 Agent Registry Structure

```json
{
  "agents": [
    {
      "agent_id": "BackendModelAgent",
      "role": "Generates domain models from entity definitions",
      "layer_type": "backend_models",
      "output_scope": "backend/models",
      "constraints": [
        "No business logic",
        "No API routes"
      ]
    },
    {
      "agent_id": "BackendServiceAgent",
      "role": "Implements business logic using domain models",
      "layer_type": "backend_services",
      "output_scope": "backend/services",
      "constraints": [
        "No API routing",
        "No schema definitions"
      ]
    },
    {
      "agent_id": "BackendRouteAgent",
      "role": "Exposes HTTP APIs using backend services",
      "layer_type": "backend_routes",
      "output_scope": "backend/routes",
      "constraints": [
        "No business logic",
        "Only call services"
      ]
    },
    {
      "agent_id": "FrontendAgent",
      "role": "Creates a basic UI to interact with backend APIs",
      "layer_type": "frontend_ui",
      "output_scope": "frontend",
      "constraints": [
        "No backend logic",
        "UI only"
      ]
    }
  ]
}
```

This registry is **system configuration**, not an artifact generated by the workflow.

---

## 5. Inputs

The Architect operates in **two modes**, driven entirely by input presence.

---

### 5.1 Mode 1 — INITIAL ARCHITECTURE CREATION

#### Trigger Condition
- No existing architecture is present

#### Inputs
```python
intent: dict
existing_architecture: None
agent_registry: list[dict]
```

#### Responsibilities
- Determine which execution layers are required based on intent
- Select appropriate agents from the registry
- Assign stable layer IDs
- Define filesystem paths
- Declare dependency order

---

### 5.2 Mode 2 — ITERATIVE ARCHITECTURE UPDATE

#### Trigger Condition
- Existing architecture is present

#### Inputs
```python
intent: dict
existing_architecture: dict
agent_registry: list[dict]
```

#### Responsibilities
- Preserve all existing architectural identifiers
- Reuse existing layers and paths
- Validate that existing layers still satisfy the updated intent
- Add new layers **only if** the updated intent introduces fundamentally new requirements
- Never rename, remove, or repurpose existing layers

The existing architecture acts as a **hard constraint**, not a suggestion.

---

## 6. Output Contract — architecture.json

### 6.1 Canonical Output Location

```
generated_apps/<app_id>/spec/architecture.json
```

Each run overwrites the previous version and is validated by the orchestrator.

---

### 6.2 Top-Level Schema

```json
{
  "architecture_version": "1.0",

  "tech_stack": {
    "backend": "fastapi",
    "frontend": "streamlit"
  },

  "execution_layers": [
    {
      "id": "backend_models",
      "type": "code_generation",
      "generator": "BackendModelAgent",
      "path": "backend/models",
      "depends_on": []
    },
    {
      "id": "backend_services",
      "type": "code_generation",
      "generator": "BackendServiceAgent",
      "path": "backend/services",
      "depends_on": ["backend_models"]
    },
    {
      "id": "backend_routes",
      "type": "code_generation",
      "generator": "BackendRouteAgent",
      "path": "backend/routes",
      "depends_on": ["backend_services"]
    },
    {
      "id": "frontend_ui",
      "type": "code_generation",
      "generator": "FrontendAgent",
      "path": "frontend",
      "depends_on": ["backend_routes"]
    }
  ]
}
```

---

## 7. Execution Layers (Core Concept)

### 7.1 Definition

An **execution layer** is the smallest independently executable planning unit.

Each layer:
- Maps to exactly one generator agent from the registry
- Owns a specific filesystem subtree
- Declares its upstream dependencies

The Architect only defines layers — it does not execute them.

---

### 7.2 Layer Fields Explained

| Field | Meaning |
|------|--------|
| `id` | Stable, immutable identifier (primary orchestration key) |
| `type` | Layer category (code_generation for MVP) |
| `generator` | Agent selected from the agent registry |
| `path` | Filesystem root owned by this layer |
| `depends_on` | Upstream layer IDs |

---

## 8. Stability Guarantees

### 8.1 Identifier Stability

Once an execution layer ID is created:
- It must never change
- It must never be reused for a different purpose

All downstream systems (orchestrator, code map, impact analysis) key off these IDs.

---

### 8.2 Path and Generator Stability

For existing layers:
- `path` must remain unchanged
- `generator` must remain unchanged

Any violation is considered a planner error.

---

## 9. Behavior During Iteration

When intent evolves:

1. Architect receives updated intent, existing architecture, and agent registry
2. It checks whether existing layers still satisfy the intent
3. If yes:
   - Re-emit the architecture unchanged
4. If no:
   - Append new execution layers with new IDs
   - Select agents exclusively from the registry

Existing layers are never modified.

---

## 10. Validation by Orchestrator

The Architect output is **validated deterministically** by the orchestrator.

### Validation Rules
- All previous layer IDs must still exist
- Paths and generators for existing layers must be unchanged
- All generators must exist in the agent registry

Any violation results in:
- Immediate failure
- Optional retry with reinforced constraints

---

## 11. Explicit Non-Responsibilities

The Architect explicitly does **not**:
- Perform intent diffing
- Decide which layers are affected by changes
- Perform selective regeneration
- Generate or modify code
- Validate generated code

These responsibilities belong to the orchestrator and generator agents.

---

## 12. Why This Design Is Correct

This design:
- Enforces architectural determinism
- Prevents LLM-driven structural drift
- Makes impact analysis tractable
- Cleanly separates planning from execution

The Architect defines **structure**, not **behavior**.

---

## 13. One-Paragraph Summary (For README / Evaluation)

The Architect Agent is a stateless LangGraph node responsible for converting a validated intent into a stable execution architecture. It plans execution layers using a predefined, closed-world agent registry, assigns immutable identifiers, declares dependencies, and preserves structural consistency across iterations by receiving the existing architecture as a constraint. By separating architectural planning from orchestration and code generation, this design enables deterministic execution, safe feedback-driven evolution, and robust agentic control.

